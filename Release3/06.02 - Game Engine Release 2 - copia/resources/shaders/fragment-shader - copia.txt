#version 150

struct Material {
	vec3 ambient;
	vec3 diffuse;
	vec3 specular;
	float shininess;
}; 
//The fragment shader operates on each pixel in a given polygon

//We declare the input variables that come from the vertex shader
	//fragment color: It's an interpolation of the color based on the triangles vertices
in vec4 fragmentColor;
in vec2 fragmentTextureCoordinates;
in vec3 fragmentNormal;
in vec3 fragmentPosition;

//It will output a color into the screen.
//Program works with 4 colors, which will be directly send to the screen. 
//That's why the color that we have to send has 4 components (RGBA)


out vec4 finalColor;

//information provided by the OpenGL
uniform sampler2D textureData;
uniform int drawMode;
uniform int lightingEnabled;
uniform int isALightSource;
uniform vec3 lightPosition;
uniform vec3 viewerPosition;
uniform Material material;
uniform Material lightColor;


void main() 
{
	//Assign the color based on the color the vertices 

	if(isALightSource == 0)
	{
			switch (drawMode) {
				case 0:
					finalColor = fragmentColor;
					break;
				case 1:
					finalColor=texture(textureData,fragmentTextureCoordinates);
					break;
				default: 
					finalColor = fragmentColor * texture(textureData,fragmentTextureCoordinates);
					break;
			}
	 }

	 if (lightingEnabled==1) 
	 {			
				//Ambient component
			vec3 ambient=material.ambient*lightColor.ambient;
		
				//Diffuse component
			vec3 norm = normalize(fragmentNormal);
			vec3 lightDir = normalize(lightPosition - fragmentPosition);  

			float diff = max(dot(norm, lightDir), 0.0);
			vec3 diffuse = lightColor.diffuse* diff * material.diffuse;

				//Specular component
			vec3 viewDir = normalize(viewerPosition - fragmentPosition);
			vec3 reflectDir = reflect(-lightDir, norm);  
			float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
			vec3 specular = lightColor.specular * spec * material.specular;  

			
			finalColor=vec4((ambient+diffuse+specular),1)*finalColor;
			

			finalColor = vec4((ambient),1) * finalColor;
			
			
		}
	
	else {
		if (lightingEnabled==1) 
		{
			finalColor=vec4(lightColor.specular,1.0f);
		}
		
		else {
				//Ambient component
		/*	vec3 ambient=material.ambient*lightColor.ambient;
		
				//Diffuse component
			vec3 norm = normalize(fragmentNormal);
			vec3 lightDir = normalize(lightPosition - fragmentPosition);  

			float diff = max(dot(norm, lightDir), 0.0);
			vec3 diffuse = lightColor.diffuse* diff * material.diffuse;

				//Specular component
			vec3 viewDir = normalize(viewerPosition - fragmentPosition);
			vec3 reflectDir = reflect(-lightDir, norm);  
			float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
			vec3 specular = lightColor.specular * spec * material.specular;  */

			
			finalColor = vec4((material.ambient),1) * finalColor;
			//+diffuse+specular

			//finalColor = vec4((ambient),1) * finalColor;
			//finalColor = fragmentColor * texture(textureData,fragmentTextureCoordinates);
			//finalColor = vec4((material.ambient*lightColor.ambient),1) * finalColor;
		}
	}
	
}

